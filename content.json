{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/12/04/hello-world/"},{"title":"","text":"spring注解驱动开发 @Bean 给容器中注册一个bean，类型为返回值类型，id默认用方法名作为id @ComponentScan value:指定要扫描的包 excludeFilters：指定扫描的时候按照什么规则排除哪些组件 includeFilters：指定扫描的时候按照什么规则包含哪些组件，必须指定useDefaultFilters为false FilterType.ANNOTATION 按照注解 assignable_type 按照给定的类型 aspectj 使用aspectj表达式 regex 使用正则表达时 custom 使用自定义规则 1234567891011public class MyTypeFilter implements TypeFilter { public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException { ClassMetadata classMetadata = metadataReader.getClassMetadata(); String className = classMetadata.getClassName(); System.out.println(className+&quot;=======&quot;); if (className.contains(&quot;er&quot;)) { return true; } return false; }} @scope 指定实例的作用域 singleton：单实例的(默认值)，ioc容器启动会调用方法创建对象放到ioc容器中，以后每次获取就是从容器中拿 可以使用@lazy指定是否懒加载 prototype：多实例的，ioc启动不会创建对象，只有获取对象的时候才会创建 @Conditional 按照一定的条件进行判断，满足条件给容器中注册bean Class&lt;? extends Condition&gt;[] value() ConditionContext：判断条件能使用的上下文环境 AnnotatedTypeMetadata：注释信息 1234567891011121314/** * ConditionContext：判断条件能使用的上下文环境 * AnnotatedTypeMetadata：注释信息 */public class LinuxCondition implements Condition { public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { Environment environment = context.getEnvironment(); String property = environment.getProperty(&quot;os.name&quot;); if (property.contains(&quot;linux&quot;)) { return true; } return false; }} @Import 快速给容器中导入一个组件，导入组件，id默认是全类名 Class&lt;?&gt;[] value(); @ImportSelector 返回需要导入的组件的全类名数组 12345678910public class MyImportSelector implements ImportSelector { public String[] selectImports(AnnotationMetadata importingClassMetadata) {// System.out.println(importingClassMetadata); String[] memberClassNames = importingClassMetadata.getMemberClassNames(); for (String memberClassName : memberClassNames) { System.out.println(&quot;memberClassName = &quot; + memberClassName); } return new String[0]; }} @ImportBeanDefinitionRegistrar 手动注册bean到容器中 12345678910public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar { public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) { boolean bill = registry.containsBeanDefinition(&quot;bill&quot;); boolean person = registry.containsBeanDefinition(&quot;person&quot;); if (bill &amp;&amp; person) { RootBeanDefinition beanDefinition = new RootBeanDefinition(Windows.class); registry.registerBeanDefinition(&quot;windows&quot;,beanDefinition); } }} FactoryBean 1234567891011121314151617public class ColorFactoryBean implements FactoryBean&lt;Color&gt; { public Color getObject() throws Exception { return new Color(); } public Class&lt;?&gt; getObjectType() { return Color.class; } /** * 是否是单实例，true为单实例 * @return */ public boolean isSingleton() { return false; }} 默认获取到的是工厂bean调用getObject创建的对象 要获取工厂bean本身，我们需要给id前面加一个&amp;，&amp;colorFactoryBean bean的生命周期 bean创建 单实例：在容器启动的时候就创建对象 多实例：在每次获取的时候创建对象 初始化 对象创建完成，并赋值好，调用初始化方法 销毁 多实例的bean容器关闭的时候，调用 多实例的bean不会销毁 通过@Bean注解实现 通过bean实现InitializingBean(定义初始化逻辑)，DisposableBean(定义销毁逻辑)接口 使用JSR250，@PostConstruct，在bean创建完成并且属性赋值完成，来执行初始化方法，@PreDestroy，在容器销毁bean之前进行清理工作 自动装配","link":"/2022/12/04/spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"},{"title":"### 我的第一篇文章","text":"","link":"/2022/12/04/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"}],"tags":[],"categories":[]}